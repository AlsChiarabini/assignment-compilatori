

using namespace llvm;
#include <cmath>


// Funzione per verificare se un numero è una potenza di 2
bool isPowerOfTwo(int64_t num) {
    return num > 0 && (num & (num - 1)) == 0;
}


bool prova_opt_mul(BinaryOperator *BinOP){


    if (BinOP->getOpcode() == Instruction::Mul) {  // Controlla se è una moltiplicazione
                if (ConstantInt *C = dyn_cast<ConstantInt>(OP2)) {  // Verifica se l'operando destro è una costante
                    int64_t num = C->getSExtValue(); // Estrai il valore della costante con segno


                    // Controlla se num, num-1 o num+1 sono potenze di 2
                    if (isPowerOfTwo(num)) {
                        // Sostituisci con uno shift a sinistra
                        Instruction *newInst = BinaryOperator::CreateShl(OP1, ConstantInt::get(C->getType(), log2(num)), "", &Inst);
                        BinOP->replaceAllUsesWith(newInst);
                        Iter = BinOP->eraseFromParent();
                        return true;
                    } else if (isPowerOfTwo(num - 1)) {
                        // Sostituisci con shift e sottrazione
                        Instruction *shlInst = BinaryOperator::CreateShl(OP1, ConstantInt::get(C->getType(), log2(num - 1)), "", &Inst);
                        Instruction *subInst = BinaryOperator::CreateSub(shlInst, OP1, "", &Inst);
                        BinOP->replaceAllUsesWith(subInst);
                        Iter = BinOP->eraseFromParent();
                        return true;


                    } else if (isPowerOfTwo(num + 1)) {
                        // Sostituisci con shift e somma
                        Instruction *shlInst = BinaryOperator::CreateShl(OP1, ConstantInt::get(C->getType(), log2(num + 1)), "", &Inst);
                        Instruction *addInst = BinaryOperator::CreateAdd(shlInst, OP1, "", &Inst);
                        BinOP->replaceAllUsesWith(addInst);
                        Iter = BinOP->eraseFromParent();
                        return true;
                    }
                }


                // Gestione caso particolare: moltiplicazione con 0
                if (ConstantInt *C = dyn_cast<ConstantInt>(OP1)) {
                    if (C->isZero()) {
                        // Sostituisci con 0
                        BinOP->replaceAllUsesWith(C);
                        Iter = BinOP->eraseFromParent();
                        return true;
                    }
                }


                // Gestione caso particolare: moltiplicazione con numeri negativi
                if (ConstantInt *C = dyn_cast<ConstantInt>(OP2)) {
                    if (C->isNegative()) {
                        int64_t absNum = -C->getSExtValue();
                        if (isPowerOfTwo(absNum)) {
                            // Esegui uno shift e una sottrazione
                            Instruction *shlInst = BinaryOperator::CreateShl(OP1, ConstantInt::get(C->getType(), log2(absNum)), "", &Inst);
                            Instruction *subInst = BinaryOperator::CreateSub(ConstantInt::get(C->getType(), 0), shlInst, "", &Inst);
                            BinOP->replaceAllUsesWith(subInst);
                            Iter = BinOP->eraseFromParent();
                            return true;
                        }
                    }
                }
            }
   
    return false;
}








bool prova_opt_div(BinaryOperator *BinOP) {


    if (BinOP->getOpcode() == Instruction::SDiv) {  
        if (ConstantInt *C = dyn_cast<ConstantInt>(BinOP->getOperand(1))) {


            int64_t num = C->getSExtValue();
            if (isPowerOfTwo(std::abs(num))) {          
               
                int valore_shift = static_cast<int>(log2(std::abs(num)));
                Instruction *shiftInst = BinaryOperator::CreateAShr(BinOP->getOperand(0), ConstantInt::get(C->getType(), valore_shift), "", BinOP);


                // Se il divisore è negativo, invertiamo il segno del risultato
                if (num < 0) {
                    Instruction *negInst = BinaryOperator::CreateSub(ConstantInt::get(BinOP->getType(), 0), shiftInst, "", BinOP);
                    BinOP->replaceAllUsesWith(negInst);
                } else {
                    BinOP->replaceAllUsesWith(shiftInst);
                }


                BinOP->eraseFromParent();
                return true;
            }
        }
    }
   
    return false; // Nessuna ottimizzazione applicata
}




bool runOnBasicBlock(BasicBlock &B) {
    bool changed = false;


    for (auto Iter = B.begin(); Iter != B.end(); ) {  // Iteriamo sulle istruzioni del BasicBlock
        Instruction &Inst = *Iter++;


        if (BinaryOperator *BinOP = dyn_cast<BinaryOperator>(&Inst)) {  // Controlla se è un'operazione binaria
           
            changed = prova_opt_mul(BinOP);
            if (!changed) prova_opt_div(BinOP);
           
        }
    }


    return changed;
}


bool runOnFunction(Function &F) {
    bool Transformed = false;


    for (auto &BB : F) {  // Itera direttamente sui BasicBlock della funzione
        if (runOnBasicBlock(BB)) {
            Transformed = true;
        }
    }


    return Transformed;
}

