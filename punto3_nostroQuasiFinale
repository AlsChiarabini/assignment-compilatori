using namespace llvm;



Value* trova_op_duale(BinaryOperator *BinOp, BinaryOperator *NextBinOp) {
   int64_t constVal = 0;
   int64_t constVal2 = 0;
   Value *varOp = nullptr;




   // Identifica la costante e la variabile in BinOp
   if (auto *C1 = dyn_cast<ConstantInt>(BinOp->getOperand(1))) {
       constVal = C1->getSExtValue();
       varOp = BinOp->getOperand(0);  // L'operando variabile è il primo
   } else if (auto *C2 = dyn_cast<ConstantInt>(BinOp->getOperand(0))) {
       constVal = C2->getSExtValue();
       varOp = BinOp->getOperand(1);  // L'operando variabile è il secondo
   }




   // Identifica la costante in NextBinOp
   if (auto *C1 = dyn_cast<ConstantInt>(NextBinOp->getOperand(1))) {
       constVal2 = C1->getSExtValue();
   } else if (auto *C2 = dyn_cast<ConstantInt>(NextBinOp->getOperand(0))) {
       constVal2 = C2->getSExtValue();
   }




   // Verifica se le operazioni sono duali e restituisce la variabile corretta
   if ((BinOp->getOpcode() == Instruction::Add && NextBinOp->getOpcode() == Instruction::Sub && constVal == constVal2) ||
       (BinOp->getOpcode() == Instruction::Sub && NextBinOp->getOpcode() == Instruction::Add && constVal == constVal2) ||
       (BinOp->getOpcode() == Instruction::Mul && NextBinOp->getOpcode() == Instruction::SDiv && constVal == constVal2 && constVal != 0) ||
       (BinOp->getOpcode() == Instruction::SDiv && NextBinOp->getOpcode() == Instruction::Mul && constVal == constVal2 && constVal != 0)) {
       return varOp;
   }




   return nullptr;
}





bool controlla_prossime_istruzioni(BinaryOperator *BinOp, BasicBlock::iterator Iter, BasicBlock &BB) {
   bool modifica = false;
   Value *X = BinOp->getOperand(0);
   Value *Y = BinOp->getOperand(1);




   if (dyn_cast<ConstantInt>(Y) || ((BinOp->getOpcode() == Instruction::Add || BinOp->getOpcode() == Instruction::Mul) && dyn_cast<ConstantInt>(X))) {
       std::vector<Instruction*> to_erase;
       for (auto NextIter = std::next(Iter); NextIter != BB.end(); ++NextIter) {
           Instruction *NextInst = &*NextIter;
           if (auto *NextBinOp = dyn_cast<BinaryOperator>(NextInst)) {
               Value *A = NextBinOp->getOperand(0);
               Value *B = NextBinOp->getOperand(1);
               if (A == BinOp || ((NextBinOp->getOpcode() == Instruction::Add || NextBinOp->getOpcode() == Instruction::Mul) && B == BinOp)) {
                    outs() << "cerco op duale\n";
                   Value *replacement = trova_op_duale(BinOp, NextBinOp);
                   if (replacement) {
                       NextBinOp->replaceAllUsesWith(replacement);
                       to_erase.push_back(NextBinOp);
                       modifica = true;
                   }
               }
           }
       }
       for (auto *Inst : to_erase) {
           Inst->eraseFromParent();
       }
   }
   return modifica;
}




bool runOnBasicBlock(BasicBlock &B) {
   bool changed = false;
   for (auto Iter = B.begin(); Iter != B.end(); ++Iter) {
       if (auto *BinOp = dyn_cast<BinaryOperator>(&*Iter)) {
           if (controlla_prossime_istruzioni(BinOp, Iter, B))
               changed = true;
       }
   }
   return changed;
}






bool runOnFunction(Function &F) {
   bool Transformed = false;
   for (auto &BB : F) {
       if (runOnBasicBlock(BB))
           Transformed = true;
   }
   return Transformed;
}




